#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const srcDir = path.join(__dirname, '..', 'src');
const componentsDir = path.join(srcDir, 'components');
const indexFile = path.join(srcDir, 'index.ts');

/**
 * Recursively find all TypeScript files in a directory
 */
function findTsFiles(dir, extensions = ['.ts', '.tsx']) {
  const files = [];

  function traverse(currentDir) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);

      if (entry.isDirectory()) {
        traverse(fullPath);
      } else if (
        entry.isFile() &&
        extensions.some((ext) => entry.name.endsWith(ext))
      ) {
        // Skip story files, test files, and spec files
        if (
          !entry.name.includes('.stories.') &&
          !entry.name.includes('.test.') &&
          !entry.name.includes('.spec.')
        ) {
          files.push(fullPath);
        }
      }
    }
  }

  traverse(dir);
  return files;
}

/**
 * Convert absolute path to relative import path
 */
function toImportPath(filePath, basePath) {
  const relativePath = path.relative(basePath, filePath);
  // Remove file extension and normalize path separators
  const importPath = relativePath
    .replace(/\.(ts|tsx)$/, '')
    .replace(/\\/g, '/');
  return `./${importPath}`;
}

/**
 * Organize files by category based on their directory structure
 */
function organizeFiles(files, baseDir) {
  const organized = {};

  for (const file of files) {
    const relativePath = path.relative(baseDir, file);
    const pathParts = relativePath.split(path.sep);

    if (pathParts.length >= 2) {
      const category = pathParts[0]; // e.g., 'canvas', 'composition', 'content', 'control'
      if (!organized[category]) {
        organized[category] = [];
      }
      organized[category].push(file);
    }
  }

  // Sort files within each category
  Object.keys(organized).forEach((category) => {
    organized[category].sort();
  });

  return organized;
}

/**
 * Generate the index.ts content
 */
function generateIndexContent() {
  const lines = [
    '// DO NOT EDIT - Autogenerated by /scripts/generate-index.mjs',
    '// Main entry point for @wrap.ngo/evergreen component library',
    '',
  ];

  // Process components
  if (fs.existsSync(componentsDir)) {
    const componentFiles = findTsFiles(componentsDir);
    const organizedComponents = organizeFiles(componentFiles, componentsDir);

    const categoryNames = {
      canvas: 'Canvas Components',
      composition: 'Composition Components',
      content: 'Content Components',
      control: 'Control Components',
    };

    Object.keys(organizedComponents)
      .sort()
      .forEach((category) => {
        const categoryTitle =
          categoryNames[category] ||
          `${category.charAt(0).toUpperCase() + category.slice(1)} Components`;
        lines.push(`// ${categoryTitle}`);

        organizedComponents[category].forEach((file) => {
          const importPath = toImportPath(file, srcDir);
          lines.push(`export * from '${importPath}';`);
        });

        lines.push('');
      });
  }

  return lines.join('\n');
}

/**
 * Main function
 */
function main() {
  console.log('ğŸ”„ Generating index.ts...');

  try {
    const content = generateIndexContent();
    fs.writeFileSync(indexFile, content, 'utf8');
    console.log('âœ… Successfully generated src/index.ts');

    // Count exports for reporting
    const exportCount = (content.match(/^export \*/gm) || []).length;
    console.log(`ğŸ“¦ Exported ${exportCount} modules`);
  } catch (error) {
    console.error('âŒ Error generating index.ts:', error);
    process.exit(1);
  }
}

main();
